<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Before You Started · A Julia Tutorial for Physicists</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://rogerluo.me/TutorialForPhysicists.jl/latest/why.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>A Julia Tutorial for Physicists</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="why.html">Before You Started</a><ul class="internal"><li><a class="toctext" href="#Why-choose-Julia-1">Why choose Julia</a></li><li><a class="toctext" href="#When-choose-Julia-1">When choose Julia</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="why.html">Before You Started</a></li></ul><a class="edit-page" href="https://github.com/Roger-luo/TutorialForPhysicists.jl/blob/master/docs/src/why.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Before You Started</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Before-You-Started-1" href="#Before-You-Started-1">Before You Started</a></h1><p>Before you start to learn Julia, I have some personal suggestions and experience to share.</p><h2><a class="nav-anchor" id="Why-choose-Julia-1" href="#Why-choose-Julia-1">Why choose Julia</a></h2><p>There are plenty of languages that is able to do numerical computing well but why do you choose Julia? This is a frequently asked questions. Usually, people cannot understand why we choose Julia rather than Python, MATLAB, Lua, Lisp, C/C++ or the new comers like Rust/Go.</p><p>They are great languages indeed, and in fact, I have been a heavy user in using Python and C/C++ for deep learning and quantum physics during 2016-2018. But I found that things were not what I expected. As an researcher in quantum physics, I would like to focus more on algorithms and theories rather than High Performance Computing (HPC) and compiler optimizations.</p><h3><a class="nav-anchor" id="Designed-for-Scientific-Computing-1" href="#Designed-for-Scientific-Computing-1">Designed for Scientific Computing</a></h3><p>Firstly, languages like Python, C/C++ were designed for general purpose rather than <strong>Scientific Computing</strong>, and as a heavy user of Python, I found it is very convenient, flexible and productive if what you are working on have already provide python wrappers. </p><p>For example, for web services, we have great frameworkss like: </p><ul><li><p><a href="https://github.com/django/django">Django</a></p></li><li><p><a href="https://github.com/pallets/flask">Flask</a> </p></li><li><p>etc. </p></li></ul><p>For general purpose <strong>linear algebra</strong> and <strong>scientific computing</strong>, we have</p><ul><li><p><a href="https://github.com/numpy/numpy">numpy</a></p></li><li><p><a href="https://github.com/scipy/scipy">scipy</a></p></li><li><p><a href="https://github.com/pandas-dev/pandas">pandas</a></p></li><li><p>etc.</p></li></ul><p>And in recent years, the bloom of <strong>deep learning</strong> is based on a number of deep learning frameworks that provides Python wrappers: </p><ul><li><p><a href="https://github.com/tensorflow/tensorflow">TensorFlow</a></p></li><li><p><a href="https://github.com/pytorch/pytorch">PyTorch</a></p></li><li><p><a href="https://github.com/apache/incubator-mxnet">MXNet</a></p></li><li><p>etc.</p></li></ul><p>Moreover, in the field of quantum physics and quantum chemistry, we have</p><ul><li><p><a href="https://github.com/sunqm/pyscf">PySCF</a></p></li><li><p><a href="https://github.com/ProjectQ-Framework/ProjectQ">Project Q</a></p></li><li><p><a href="https://github.com/quantumlib/OpenFermion">OpenFermion</a></p></li><li><p><a href="https://github.com/qutip/qutip">QuTiP</a></p></li></ul><p>However, Python is only an wrapper in most packages above, and for projects written mainly in Python like <strong>Project Q</strong> have been sufferring performance issue.</p><pre><code class="language-python">projectq 19.45s user 0.72s system 100% cpu 20.173 total
scipy  10.68s user 0.13s system 100% cpu 10.813 total</code></pre><p>This is because the dynamical feature of Python itself provides you its simple and flexible experience but costs extra overhead on its performance and make the language itself hard to optimize. You cannot write a performance-expensive function in pure Python. However, most researchers in the field of Physics do have the time and should not need to learn how to write C/C++ programs for Python. </p><p>Even with <strong>numpy</strong> and <strong>scipy</strong>, in the field of quanutm physics, the performance is still not enough, especially</p><p>To overcome this performance issue and let research users focus on what they should focus on, developers usually have the following options:</p><ul><li><p>write a backend in pure C/C++ and bind it to Python with C API (You can use <a href="https://github.com/pybind/pybind11">pybind11</a> now) or for small projects there is <a href="https://cffi.readthedocs.io/en/latest/">cffi</a></p></li><li><p>rewrite part of the code in <a href="http://cython.org/">Cython</a> as a subset of the language</p></li><li><p>use JIT compilers like: <a href="https://numba.pydata.org/">numba</a></p></li></ul><h2><a class="nav-anchor" id="When-choose-Julia-1" href="#When-choose-Julia-1">When choose Julia</a></h2><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a></footer></article></body></html>
